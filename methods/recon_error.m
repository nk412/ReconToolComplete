function [ rec_err ] = recon_error( position_data, reconstructed_trajectory, model_params )
% [rec_err] = recon_error(position_data, reconstructed_trajectory, model_params)
%
% This function compares the estimated position returned by the
% reconstruction method with the true position of the animal.
%
% Input-
% position_data - 			Positional data in the form of a Tx3 matrix, where T is the
%                 			number of timesteps. The three columns correspond to timestep,
%                 			X coordinate at T and Y coordinate at T respectively.
% reconstructed_trajectory - A cell array containing I matrices, where I is the number of 
% 							reconstructed intervals. Each matrix is of size Tx3, where T
%							is the number of timesteps in the interval, and the second
%							and third column contain the estimated X and Y co-ordinate of
%							the animal at that timestep. This object is returned by the
%							reconstruction method.
% model_params  - 			Cell array containing parameters such as firing rates and
%                 			occupancy matrices. This object is generated by the training
%                 			method, given the spiking and positinal data.
%
% Output-
% rec_err   	-	A cell array containing I matrices, where I is the number of
% 				intervals used for reconstruction. Each matrix is a Tx6 matrix,
% 				where T is the number of timesteps within the specified interval.
%
% 		rec_err{I}(:,1) - Time stamp for every timestep in the interval.
% 		rec_err{I}(:,2) - Estimated X coordinate at the timestep.
% 		rec_err{I}(:,3) - Estimated Y coordinate at the timestep.
% 		rec_err(I)(:,4) - True X coordinate of the animal as per position_data.
% 		rec_err(I)(:,5) - True Y coordinate of the animal as per position_data.
% 		rec_err(I)(:,6) - Euclidian distance between true and estimated points
% 	where I is the number of recontructed intervals.




%------------Discretizing Position data into bins------------%
binsize_grid=model_params{2};
max_x=max(position_data(:,2));  % get max X value
max_y=max(position_data(:,3));  % get max Y value
n_grid=binsize_grid(1);       % horizontal divisions, n
m_grid=binsize_grid(2);       % vertical divisions, m
m_grid=max_x/m_grid;            % bin width
n_grid=max_y/n_grid;            % bin height




unscaled_pos=position_data;



for x=1:numel(position_data(:,1))
    position_data(x,2)=round(position_data(x,2)/m_grid);
    if(position_data(x,2)==0)
    	position_data(x,2)==1;
    end

    position_data(x,3)=round(position_data(x,3)/n_grid);
    if(position_data(x,3)==0)
    	position_data(x,3)==1;
    end

end



%------------------Error calculation---------------------------%
intervals=numel(reconstructed_trajectory);

rec_err={};
for intr=1:intervals
	out_intervals=[];
	timesteps=numel(reconstructed_trajectory{intr}(:,1));
	interval_data=reconstructed_trajectory{intr};
	for each_time=1:timesteps


			true_time_index=findnearest(interval_data(each_time,1),position_data);
		
		% if(each_time==1)
		% 	true_time_index=findnearest(interval_data(each_time,1),position_data);
		% else
  %           val=true_time_index;
  %           temp_time=interval_data(each_time,1);
  %           while(position_data(val,1)<temp_time)
  %               val=val+1;
  %           end
  %           true_time_index=val-1;
  %       end




        % if(true_time_index==0)
        % 	true_time_index=true_time_index+1;
        % end

		true_x = position_data(true_time_index,2);
		true_y = position_data(true_time_index,3);
		true_unscaled_x=unscaled_pos(true_time_index,2);
		true_unscaled_y=unscaled_pos(true_time_index,3);

		est_x = interval_data(each_time,2);
		est_y = interval_data(each_time,3);

		% center of square
		est_unscaled_x=(est_x*m_grid)-(m_grid/2);
		est_unscaled_y=(est_y*n_grid)-(n_grid/2);

		time_val = interval_data(each_time,1);

		%----find euclidian distance------%

		error_dist=sqrt((true_x(1) - est_x(1))^2 + (true_y(1) - est_y(1))^2);
		error_dist=power(error_dist,2);

		unscaled_error=sqrt((true_unscaled_x(1) - est_unscaled_x(1))^2 + (true_unscaled_y(1) - est_unscaled_y(1))^2);
		unscaled_error=power(unscaled_error,2);

		out_intervals= [out_intervals; time_val(1), true_x(1), true_y(1), est_x(1), est_y(1), error_dist, true_unscaled_x(1),true_unscaled_y(1),est_unscaled_x(1), est_unscaled_y(1), unscaled_error];
	end
	rec_err{intr}=out_intervals;
end

end

